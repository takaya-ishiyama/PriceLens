use std::sync::Arc;

use axum::async_trait;
use domain::{
    infrastructure::interface::repository::{
        item_repository_interface::ItemRepository,
        organization_repository_interface::OrganizationRepository,
    },
    value_object::organaization::{
        organization::Organization, organization_type::ORGANIZATION_TYPE,
    },
};
use serde::{Deserialize, Serialize};
use sqlx::{prelude::FromRow, types::chrono::NaiveDateTime, Acquire, Pool, Postgres};
use uuid::Uuid;

#[derive(Clone, Debug)]
pub struct ItemRepositoryImpl {
    db: Arc<Pool<Postgres>>,
}

// #[derive(Clone, Debug, PartialEq, PartialOrd, sqlx::Type, Deserialize, Serialize)]
// #[sqlx(type_name = "organization_type", rename_all = "lowercase")]
// pub enum OrganizationType {
//     #[sqlx(rename = "PUBLIC")]
//     PUBLIC,
//     #[sqlx(rename = "PRIVATE")]
//     PRIVATE,
// }
//
#[derive(FromRow)]
struct CreatedItem {
    id: Uuid,
    organization_id: String,
    name: String,
    created_at: Option<NaiveDateTime>,
    updated_at: Option<NaiveDateTime>,
}

#[async_trait]
impl ItemRepository for ItemRepositoryImpl {
    fn new(db: Arc<Pool<Postgres>>) -> Self {
        Self { db }
    }
    async fn create(&self, organization_id: &str, name: &str) -> Result<Item, String> {
        let mut pool = self.db.acquire().await.unwrap();
        let conn = pool.acquire().await.unwrap();
        let mut tx = conn.begin().await.unwrap();

        let item = sqlx::query_as!(
            CreatedItem,
            r#"INSERT INTO Item (name, organization_id) VALUES ($1, $2) RETURNING *"#,
            name,
            organization_id
        )
        .find_many(&mut *tx)
        .await;
    }
    async fn find_names(&self, organization_id: &str) -> Result<Vec<Item>, String> {}
}

#[cfg(test)]
mod tests {

    use sqlx::PgPool;

    use crate::test::{setup_testdb::setup_database, stb_data::stb_organization};

    use super::*;

    // #[sqlx::test]
    // async fn test_create_true_response(pool: PgPool) -> sqlx::Result<()> {
    //
    // }
}
